# -*- coding: utf-8 -*-
"""Traceroute_with_Reverse_DNS_Lookup_Graph_Updated.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/13q0CKTQwtLNwH5wwsvE5-ZISb5fx1I0N
"""

!pip install scapy
!pip install networkx

def draw_graph(G, edge_latencies):
    pos = nx.spring_layout(G)

    # Draw nodes 
    degree = G.degree()
    colors = [degree[node] for node in G.nodes()]
    nx.draw(G, pos, node_color=colors, with_labels=True)

    # Draw edges based on latency
    edge_widths = [edge_latencies[edge] for edge in G.edges()]
    nx.draw_networkx_edges(G, pos, width=edge_widths)

    plt.show()
    plt.tight_layout()

import networkx as nx
import matplotlib.pyplot as plt
from scapy.all import *
def get_domain_name(ip_address):
        try:
            # Reverse DNS lookup 
            domain_name = socket.gethostbyaddr(ip_address)[0]
            return domain_name
        except socket.herror:
            # Unable to resolve the domain name
            return ip_address

def traceroute(destination, max_hops):
    # Set the destination and maximum number of hops
    dport = 33434  # Destination port for traceroute
    ttl = 1

    # Create an empty graph
    G = nx.Graph()

    prev_ip = None
    edge_latencies = {}  # Latency
    while True:
        # ICMP echo request packet with the specified TTL
        packet = IP(dst=destination, ttl=ttl) / ICMP()

        start_time = time.time()
        
        reply = sr1(packet, verbose=False, timeout=1)

        latency = time.time() - start_time

        if reply is None:
            # No response received
            print(f"{ttl}. *")
        elif reply.type == 3:
            # Destination reached
            print(f"{ttl}. {reply.src}({get_domain_name(reply.src)})")
            break
        else:
            # Intermediate hop reached
            print(f"{ttl}. {reply.src} ({get_domain_name(reply.src)})")

            if prev_ip is not None:
                # Add an edge to the graph between the current and previous hop
                G.add_edge(prev_ip, reply.src)
                # Store the latency 
                edge_latencies[(prev_ip, reply.src)] = latency
            prev_ip = reply.src

        # Increment TTL 
        ttl += 1

        if ttl > max_hops:
            # Maximum number of hops reached
            break

    return G, edge_latencies



G, edge_latencies = traceroute("www.example.com", 30)
draw_graph(G, edge_latencies)